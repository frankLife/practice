#  sea.js浅析(上) #
---

分析是基于这段时间，看sea.js源码，对其cmd模块加载机制的理解而成的。seajs里面有很多不错的程序设计思路，在此整理学习。

![outline](./Sea.js_outline.png)

在seajs的github仓库中，存放着如上图展示的seajs的两大类模块，一类是工具模块。以util开头的：


1. 关于公用功能，例如数据类型判断，加载模块id生成的**util-lang模块**
2. 关于自定义事件处理的**util-events模块**
3. 关于路径解析获得模块路径、调用当前路径的**util-path模块**
4. 关于请求js、css文件，加载资源的**util-request模块**
5. 通过一个大的正则来解析依赖的**util-deps模块**
6. 虽然**config模块**没有以util开头，实际上还是为主模块服务的，依然可以作为工具模块看待，主要处理对使用sea.js的一些用户配置。

除了工具模块之外，seajs中就是实现模块机制的**module模块**

工具模块与核心的module模块之间相互依赖，形成seajs加载器

![outline](./Sea.js_outline_expand.png)

这篇文章，我们来关注下**工具模块**

##util-lang##
![util-lang](./langjs.PNG)

util-lang在代码中，有两个主要的功能：

1. 类型判断
2. 生成加载模块id

类型判断的代码比较平常，主要就是利用Object.prototype.toString.call() 或者是{}.toString.call()这种方式来写了一个工厂函数来判断数据类型，这一点，玉伯在[sea.js源码解析（三）](https://github.com/lifesinger/lifesinger.github.com/issues/175 "sea.js源码解析（三）")中讲了这个用法的历史来源。

第二个功能就是利用一个

	var _cid = 0
	function cid() {
	  return _cid++
	}

这个函数来做一个使用模块id的生成，这一点会在后面module模块讲解中提到。

##util-events##
![util-events](./eventsjs.PNG)

utl-event模块将用户的自定义事件的数据绑定到seajs.data这个同时也是作为seajs数据配置数据对象上，实现对事件的管理。其中包含3个常用方法：on、off、emit

以 事件名key -> 相应函数数组 callback Array 的方式来进行对事件信息的保存，在seajs中对外暴露的方法最后都会返回一个seajs对象满足链式调用。on方法则是往对应事件的处理函数数组中推函数
	var events = data.events = {}

	seajs.on = function(name, callback) {
	  var list = events[name] || (events[name] = [])
	  list.push(callback)
	  return seajs
	}
代码上主要是判断是否已经绑定过该事件（如果已经绑定，则说明已经有对应函数名属性下的数组），有的话，直接推入处理函数到对应数组下，没有的话则按照事件名新建数组到seajs.events上 

off方法则是找到对应事件名，删除这个属性里面的对应处理函数，如果不不传删除的对应处理函数，则默认删除该事件下的所用处理函数，如果不传参数，则默认删除所有事件

	seajs.off = function(name, callback) {
	  // Remove *all* events
	  if (!(name || callback)) {
	    events = data.events = {}
	    return seajs
	  }
	
	  var list = events[name]
	  if (list) {
	    if (callback) {
	      for (var i = list.length - 1; i >= 0; i--) {
	        if (list[i] === callback) {
	          list.splice(i, 1)
	        }
	      }
	    }
	    else {
	      delete events[name]
	    }
	  }
	
	  return seajs
	}
代码实现上，实际就是对events这个与seajs.data建立引用的事件处理对象进行事件的查找和删除，分为

1. name、callback 两个参数都不传 -> 删除所有绑定在seajs上的事件
2. 传递name一个参数 -> 直接删除seajs.events下的对应事件属性
3. 传递name、callback,则删除对应以name为名下的以callback为名的处理函数，函数引用会对应匹配，需要传递绑定时传的callback


emit则是抽出对应事件名属性下的函数进行依次调用，在emit（event，[arguments]）后面跟的参数会出入到处理函数中

	var emit = seajs.emit = function(name) {
	  var list = events[name], fn
	
	  if (list) {
	    // Copy callback lists to prevent modification
	    list = list.slice()
	    var args = Array.prototype.slice.call(arguments, 1);
	    // Execute event callbacks
	    while ((fn = list.shift())) {
	      fn.apply(null, args);
	    }
	  }
	
	  return seajs
	}

代码上主要是获得传递的除事件名外的参数，通过while循环的方式，讲获得的参数通过apply的形式调用。

##util-path##

![util-path](./pathjs.PNG)

模块加载需要处理资源的依赖加载、模块的依赖执行，而依赖加载中，所有的模块id路径处理都需要通过util-path这个模块，可见这模块的重要性。

模块进入首先是4个正则表达式

	var DIRNAME_RE = /[^?#]*\//
	
	var DOT_RE = /\/\.\//g
	var DOUBLE_DOT_RE = /\/[^/]+\/\.\.\//
	var DOUBLE_SLASH_RE = /([^:/])\/\//g

`DIRNAME_RE`的作用是获得当前文件的文件夹路径，这个表达式被封装在了`dirname()`这个方法里面使用，在seajs中，通过`dirname()`函数来获得当前页面的文件夹路径`cwd`、模块加载的初始化位置`loaderDir`。在源代码实现中与之相关的有一处需要注意：

	// Recommend to add `seajsnode` id for the `sea.js` script element
	var loaderScript = doc.getElementById("seajsnode") ||
	    scripts[scripts.length - 1]

这里的`loaderScript`的作用关系到`loaderDir`,而`loaderDir`对模块的起始加载位置（在后面的`addBase()`函数中会提到)有很大作用。而上面的代码告诉我们，如果要保证路径正确（也就是`loaderScript`正确被模块取到）那么seajs存在在页面上的位置必须是：

1. id为seajsnode的script标签
2. **最后一个引用标签









