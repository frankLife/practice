#  sea.js浅析(上) #
---

分析是基于这段时间，看sea.js源码，对其cmd模块加载机制的理解而成的。seajs里面有很多不错的程序设计思路，在此整理学习。

![outline](./Sea.js_outline.png)

在seajs的github仓库中，存放着如上图展示的seajs的两大类模块，一类是工具模块。以util开头的：


1. 关于公用功能，例如数据类型判断，加载模块id生成的**util-lang模块**
2. 关于自定义事件处理的**util-events模块**
3. 关于路径解析获得模块路径、调用当前路径的**util-path模块**
4. 关于请求js、css文件，加载资源的**util-request模块**
5. 通过一个大的正则来解析依赖的**util-deps模块**
6. 虽然**config模块**没有以util开头，实际上还是为主模块服务的，依然可以作为工具模块看待，主要处理对使用sea.js的一些用户配置。

除了工具模块之外，seajs中就是实现模块机制的**module模块**

工具模块与核心的module模块之间相互依赖，形成seajs加载器

![outline](./Sea.js_outline_expand.png)

这篇文章，我们来关注下**工具模块**

##util-lang##
![util-lang](./langjs.PNG)

util-lang在代码中，有两个主要的功能：

1. 类型判断
2. 生成加载模块id

类型判断的代码比较平常，主要就是利用Object.prototype.toString.call() 或者是{}.toString.call()这种方式来写了一个工厂函数来判断数据类型，这一点，玉伯在[sea.js源码解析（三）](https://github.com/lifesinger/lifesinger.github.com/issues/175 "sea.js源码解析（三）")中讲了这个用法的历史来源。

第二个功能就是利用一个

	var _cid = 0
	function cid() {
	  return _cid++
	}

这个函数来做一个使用模块id的生成，这一点会在后面module模块讲解中提到。

##util-events##
![util-events](./eventsjs.PNG)

utl-event模块将用户的自定义事件的数据绑定到seajs.data这个同时也是作为seajs数据配置数据对象上，实现对事件的管理。其中包含3个常用方法：on、off、emit

以 事件名key -> 相应函数数组 callback Array 的方式来进行对事件信息的保存，在seajs中对外暴露的方法最后都会返回一个seajs对象满足链式调用。on方法则是往对应事件的处理函数数组中推函数
	var events = data.events = {}

	seajs.on = function(name, callback) {
	  var list = events[name] || (events[name] = [])
	  list.push(callback)
	  return seajs
	}
代码上主要是判断是否已经绑定过该事件（如果已经绑定，则说明已经有对应函数名属性下的数组），有的话，直接推入处理函数到对应数组下，没有的话则按照事件名新建数组到seajs.events上 

off方法则是找到对应事件名，删除这个属性里面的对应处理函数，如果不不传删除的对应处理函数，则默认删除该事件下的所用处理函数，如果不传参数，则默认删除所有事件

	seajs.off = function(name, callback) {
	  // Remove *all* events
	  if (!(name || callback)) {
	    events = data.events = {}
	    return seajs
	  }
	
	  var list = events[name]
	  if (list) {
	    if (callback) {
	      for (var i = list.length - 1; i >= 0; i--) {
	        if (list[i] === callback) {
	          list.splice(i, 1)
	        }
	      }
	    }
	    else {
	      delete events[name]
	    }
	  }
	
	  return seajs
	}
代码实现上，实际就是对events这个与seajs.data建立引用的事件处理对象进行事件的查找和删除，分为

1. name、callback 两个参数都不传 -> 删除所有绑定在seajs上的事件
2. 传递name一个参数 -> 直接删除seajs.events下的对应事件属性
3. 传递name、callback,则删除对应以name为名下的以callback为名的处理函数，函数引用会对应匹配，需要传递绑定时传的callback


emit则是抽出对应事件名属性下的函数进行依次调用，在emit（event，[arguments]）后面跟的参数会出入到处理函数中

	var emit = seajs.emit = function(name) {
	  var list = events[name], fn
	
	  if (list) {
	    // Copy callback lists to prevent modification
	    list = list.slice()
	    var args = Array.prototype.slice.call(arguments, 1);
	    // Execute event callbacks
	    while ((fn = list.shift())) {
	      fn.apply(null, args);
	    }
	  }
	
	  return seajs
	}

代码上主要是获得传递的除事件名外的参数，通过while循环的方式，讲获得的参数通过apply的形式调用。

##util-path##

![util-path](./pathjs.PNG)

模块加载需要处理资源的依赖加载、模块的依赖执行，而依赖加载中，所有的模块id路径处理都需要通过util-path这个模块，可见这模块的重要性。

模块进入首先是4个正则表达式

	var DIRNAME_RE = /[^?#]*\//
	
	var DOT_RE = /\/\.\//g
	var DOUBLE_DOT_RE = /\/[^/]+\/\.\.\//
	var DOUBLE_SLASH_RE = /([^:/])\/\//g

`DIRNAME_RE`的作用是获得当前文件的文件夹路径，这个表达式被封装在了`dirname()`这个方法里面使用，在seajs中，通过`dirname()`函数来获得当前页面的文件夹路径`cwd`、模块加载的初始化位置`loaderDir`。在源代码实现中与之相关的有一处需要注意：

	// Recommend to add `seajsnode` id for the `sea.js` script element
	var loaderScript = doc.getElementById("seajsnode") ||
	    scripts[scripts.length - 1]

这里的`loaderScript`的作用关系到`loaderDir`,而`loaderDir`对模块的起始加载位置（在后面的`addBase()`函数中会提到)有很大作用。而上面的代码告诉我们，如果要保证路径正确（也就是`loaderScript`正确被模块取到）那么seajs存在在页面上的位置必须是：

1. id为seajsnode的script标签
2. seajs为最后一个script引用标签

这里还可以看出，模块的初始路径实际上是按照seajs的路径为基准的。


`DOT_RE`、`DOUBLE_DOT_RE`、`DOUBLE_SLASH_RE`这三个正则主要是运用在`realpath()`这个函数中：

	// Canonicalize a path
	// realpath("http://test.com/a//./b/../c") ==> "http://test.com/a/c"
	function realpath(path) {
	  // /a/b/./c/./d ==> /a/b/c/d
	  path = path.replace(DOT_RE, "/")
	
	  // a/b/c/../../d  ==>  a/b/../d  ==>  a/d
	  while (path.match(DOUBLE_DOT_RE)) {
	    path = path.replace(DOUBLE_DOT_RE, "/")
	  }
	
	  // a//b/c  ==>  a/b/c
	  path = path.replace(DOUBLE_SLASH_RE, "$1/")
	
	  return path
	}

从源码上我们可以看出来，首先去替换`./`这种相对路径，例如b/./c,这里的`./`实际上就是对应的`b`,那么这里`/./`就会被替换成`b/`。同样，`b/c/../d`，这里的`/../`对应的就是`b`，那么这里就会被替换成`b/`,这里的正则是`/\/[^/]+\/\.\.\//`,相当于是匹配`目标文件夹位置/被跨过的文件夹路径/../`，那么这个匹配内容会被`/`代替，这样就会实现把路径替换到基于`../`后面文件位置的上一层位置。


路径转换的最后对路径再做了一层优化，讲路径中错误的`//`纠正为`/`。

`realpath()`函数后面紧接着是`normalize()`函数，这个函数主要是去处理路径最后的资源格式符，判断处理这个路径下的文件是否为js、css，并且返回带格式符的路径，便于加载（通过`request()`函数实现）。

大家可能会发现，这里实际上并没有对`config`这个对象里面的配置进行加载处理，恩，下面会有4个函数做这个事情。

1. `parseAlias(id)`对应config里面的`alias`
2. `parsePaths(id)`对应config里面的`paths`
3. `parseVars(id)`对应config里面的`vars`
4. `parseMap(id)`对应config里面的`map`

我们来看看代码上的实现

**parseAlias:**

	function parseAlias(id) {
	  var alias = data.alias
	  return alias && isString(alias[id]) ? alias[id] : id
	}

**首先需要提到的是`seajs.config()`配置的参数都会保存到`seajs.data`上，这里的`data`是对`seajs.data`的引用。**

**这四个函数的调用顺序是`parseAlias(id)`->`parsePaths(id)`->`parseVars(id)`->`parseMap(id)`**

可以看出对alias做的事情不多，这里会去查找调用的模块名是不是有在alias有配置，有的话，则返回对应的配置信息，没有的话，则返回原有的id

**parsePaths:**

	var PATHS_RE = /^([^/:]+)(\/.+)$/
	function parsePaths(id) {
	  var paths = data.paths
	  var m
	
	  if (paths && (m = id.match(PATHS_RE)) && isString(paths[m[1]])) {
	    id = paths[m[1]] + m[2]
	  }
	
	  return id
	}

很多刚接触seajs的人可能会对path和alias产生疑惑和混淆，看下具体实现就真相大白了。

这里的`parsePath`会有一个对应使用的正则`/^([^/:]+)(\/.+)$/`,其实这个正则就是去划分两个部分，路径中第一个`/`之前的文件夹路径为**第一部分**，`/`之后的路径为**第二部分**。

然后如果有paths配置的话，进入判断逻辑`(m = id.match(PATHS_RE)) && isString(paths[m[1]])`，这里主要会去匹配**第一部分**，如果在经过`parseAlias()`处理之后的路径中，第一部分在path里面存在着配置，那么就会将第一部分进行替换。

其实`path`、`alias`按我的理解，`alias`是对在`path`的作用上再做了一层简化配置，`path`是对路径基本的简化替换配置。在`alias`中，我们需要去争对`path`中对于**第一部分**去配置，起始文件夹的位置对应`path`中的配置属性。结合`path`和`alias`去配置，才能保证路径的正确。

**parseVars**

这里的var，相当于是建立了一个可以在路径配置中可以赋值变化的变量。

首先`parseVars`函数会用到一个正则`/{([^{]+)}/g`,这个正则会匹配`{}`里面的内容，然后在路径中替换通过`{}`设置的变量。

**parseMap**

这里的Map有点类似于vars,但是不同的是在后面的`id2Url()`提到，vars的配置是以对象的方式来配置属性，是一个属性对应一个字符串，而map可以实现函数的调用替换，加入传入一个配置函数，实际上路径会通过函数加工后返回来实现配置，并且除此之外，map的配置是一个属性对应一个两个元素的数组，规则是路径中存在的数组的第一个元素会被替换成数组中的第二个元素

  	ret = isFunction(rule) ?
          (rule(uri) || uri) :
          uri.replace(rule[0], rule[1])

上面是map函数中的一段代码，可以看出map的配置方式一种是函数、一种是数组

**addBase**

addBase函数实际上是对处理路径id到一定阶段后的分流，判断路径类型，得出一个阶段性的路径结果（这个步骤结束就只剩最后一步map的替换了）

	var ABSOLUTE_RE = /^\/\/.|:\//
	var ROOT_DIR_RE = /^.*?\/\/.*?\//

	function addBase(id, refUri) {
	  var ret
	  var first = id.charAt(0)
	
	  // Absolute
	  if (ABSOLUTE_RE.test(id)) {
	    ret = id
	  }
	  // Relative
	  else if (first === ".") {
	    ret = realpath((refUri ? dirname(refUri) : data.cwd) + id)
	  }
	  // Root
	  else if (first === "/") {
	    var m = data.cwd.match(ROOT_DIR_RE)
	    ret = m ? m[0] + id.substring(1) : id
	  }
	  // Top-level
	  else {
	    ret = data.base + id
	  }
	
	  // Add default protocol when uri begins with "//"
	  if (ret.indexOf("//") === 0) {
	    ret = location.protocol + ret
	  }*
	
	  return ret
	}

从源代码上可以看到，在`addBase()`中，有四条道路：绝对路径、相对路径、根路径、顶层路径。

首先是对于绝对路径，对应的匹配正则是`/^\/\/.|:\//`，对应去检测路径中是否存在"//xxx"或者":/"，如果存在，则说明为绝对路径，那么路径id就不会再做处理，直接返回

其次是相对路径，相对路径有很明显的一点是，以`./`开头，那么在代码实现上，是去检测路径字符串中的第一个字符是否为`.`。那么在相对路径的情况下，我们要绝对路径，就首先要知道现在的路径是什么，那么这里addBase提供了一个参数`refUri`来作为当前路径的一个考证。在`(refUri ? dirname(refUri) : data.cwd`这个表达式中，会去检测是否传入`refUri`参数，如果传入的话，就以这个参数为基础加上当前调用模块的id，如果未传入的话，，经过realpath()把相对路径中的例如`../`或者`../`都处理掉得出结果路径

然后如果是根路径，也就是路径第一个字符是`/`,这里会使用到一个正则`/^.*?\/\/.*?\//`，这里回去检测目前的seajs工作路径`cwd`,如果当前的工作路径中存在
































