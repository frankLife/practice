#  sea.js浅析(下) #

这篇文章主要是记录seajs核心模块module.js。

![module.js](./modulejs.PNG)

从脑图可以简单的看到:
1. module模块中包含如`cacheMods`、`anonymouseMeta`、`fetchingList`等公共变量来调配seajs模块管理的信息。
2. 对于模块加载、依赖状态，有一个`status`枚举来实现管理
3. 通过`resolve()`、`load()`、`onload()`、`fetch()`等函数并且依赖前面提到的辅助模块来实现模块之间的加载、依赖逻辑。

下面我们进入源码来一探究竟。

和大多数框架一样，进入模块首先是全局变量的设置。

	var cachedMods = seajs.cache = {}
	var anonymousMeta
	
	var fetchingList = {}
	var fetchedList = {}
	var callbackList = {}
	
	var STATUS = Module.STATUS = {
	  // 1 - The `module.uri` is being fetched
	  FETCHING: 1,
	  // 2 - The meta data has been saved to cachedMods
	  SAVED: 2,
	  // 3 - The `module.dependencies` are being loaded
	  LOADING: 3,
	  // 4 - The module are ready to execute
	  LOADED: 4,
	  // 5 - The module is being executed
	  EXECUTING: 5,
	  // 6 - The `module.exports` is available
	  EXECUTED: 6
	}

先大致介绍下这里的全局变量：

1. `cachedMods`,在seajs中，所有加载的模块都会通过`Module()`构造并`push`到`cahedMods`中进行管理。
2. `anonymouseMeta`,这个变量的看英文的意思是“匿名元数据”，其实作用是在定义模块的时候，如果是匿名模块的话，会对还未加载的匿名模块做信息缓存。
3. `fechingList`、`fechedList`,这两个变量的作用是seajs在加载依赖模块时，对模块所正在拉取的依赖和完成拉取的依赖的管理
4. `callbackList`,这个变量与`fechingList`、`fechedList`想关联，是对加载的依赖完成之后，会去调用加载完成依赖的模块的回调函数，这里可以实现对多层依赖、相互依赖的管理。
5. `STATUS`，从可枚举的字段值可以看出，这个变量目的是为实现对模块各个状态的标志维护。

对于物理的js文件作为模块，seajs通过一个`Module()`构造器函数来初始化信息

	function Module(uri, deps) {
	  this.uri = uri
	  this.dependencies = deps || []
	  this.exports = null
	  this.status = 0
	
	  // Who depends on me
	  this._waitings = {}
	
	  // The number of unloaded dependencies
	  this._remain = 0
	}

可以从构造器函数看出，生成的每一个模块实例，包含着模块seajs对模块加载管理的基本信息:

1. `this.uri`,模块对应文件的物理路径
2. `this.dependencies`,模块需要加载的依赖模块
3. `this.exports`,和node.js类似，这个是模块暴露api的对象
4. `this.status`, 模块状态
5. `this._watings`,这里注释写得很明白，`_watings`管理的是依赖该模块的模块
6. `this.remian`,剩余的未加载的依赖模块数量

信息骨架有了，剩下的就是通过这些信息辅助，实现模块之间依赖管理的逻辑了。

首先是`resolve()`函数

	// Resolve module.dependencies
	Module.prototype.resolve = function() {
	  var mod = this
	  var ids = mod.dependencies
	  var uris = []
	
	  for (var i = 0, len = ids.length; i < len; i++) {
	    uris[i] = Module.resolve(ids[i], mod.uri)
	  }
	  return uris
	}

这个函数可以看出，主要的作用是通过调用Module.resolve函数去拿到依赖模块的物理路径数组并返回。

这里我们找到`Module.resolve()`函数来看看：

	// Resolve id to uri
	Module.resolve = function(id, refUri) {
	  // Emit `resolve` event for plugins such as text plugin
	  var emitData = { id: id, refUri: refUri }
	  emit("resolve", emitData)
	
	  return emitData.uri || seajs.resolve(emitData.id, refUri)
	}

这里我们先取出触发插件对id的改变，可以看到，主要是调用`seajs.resolve()`函数,而`seajs.resolve()`函数前面提到，主要是就是对`id`到`uri`的解析，也就是`id2Uri()`函数.

接下来就是`load()`函数:

	// Resolve module.dependencies
	Module.prototype.resolve = function() {
	  var mod = this
	  var ids = mod.dependencies
	  var uris = []
	
	  for (var i = 0, len = ids.length; i < len; i++) {
	    uris[i] = Module.resolve(ids[i], mod.uri)
	  }
	  return uris
	}
	
	// Load module.dependencies and fire onload when all done
	Module.prototype.load = function() {
	  var mod = this
	
	  // If the module is being loaded, just wait it onload call
	  if (mod.status >= STATUS.LOADING) {
	    return
	  }
	
	  mod.status = STATUS.LOADING
	
	  // Emit `load` event for plugins such as combo plugin
	  var uris = mod.resolve()
	  emit("load", uris, mod)
	
	  var len = mod._remain = uris.length
	  var m
	
	  // Initialize modules and register waitings
	  for (var i = 0; i < len; i++) {
	    m = Module.get(uris[i])
	
	    if (m.status < STATUS.LOADED) {
	      // Maybe duplicate: When module has dupliate dependency, it should be it's count, not 1
	      m._waitings[mod.uri] = (m._waitings[mod.uri] || 0) + 1
	    }
	    else {
	      mod._remain--
	    }
	  }
	
	  if (mod._remain === 0) {
	    mod.onload()
	    return
	  }
	
	  // Begin parallel loading
	  var requestCache = {}
	
	  for (i = 0; i < len; i++) {
	    m = cachedMods[uris[i]]
	
	    if (m.status < STATUS.FETCHING) {
	      m.fetch(requestCache)
	    }
	    else if (m.status === STATUS.SAVED) {
	      m.load()
	    }
	  }
	
	  // Send all requests at last to avoid cache bug in IE6-9. Issues#808
	  for (var requestUri in requestCache) {
	    if (requestCache.hasOwnProperty(requestUri)) {
	      requestCache[requestUri]()
	    }
	  }
	}

函数逻辑上会首先判断模块状态是否大于等于`LOADING`,大于`LOADING`的话，说明函数是至少是处于`LOADED`的状态，也就是模块已经依赖加载完全；等于`LOADING`的话，说明模块正在加载（也就是模块的依赖模块正在加载）的状态。

	var uris = mod.resolve()

	var len = mod._remain = uris.length

这里函数会首先拿到两个关于依赖的变量来进行对模块所依赖模块的加载状态判断。

我们可以再循环中看到，在获得依赖模块时，都会通过`Module.get(uris[i])`来取得依赖模块。

这里我们找到`Module.get()`函数：

	// Get an existed module or create a new one
	Module.get = function(uri, deps) {
	  return cachedMods[uri] || (cachedMods[uri] = new Module(uri, deps))
	}

这里会出现两种情况。


